/// TODO: doc
pub const Trb = packed struct(u128) {
    /// Type-specific data.
    _unknown1: u64,

    /// Type-specific data.
    _unknown2: u32,

    /// Cycle bit.
    cycle: u1,
    /// Type-specific data.
    _unknown3: u9,
    /// TRB type.
    ///
    /// TODO: the offset of `type` field is different in each TRB type.
    type: TrbType,
    /// Type-specific data.
    _unknown4: u16,

    /// Obtain the abstract type of the TRB.
    pub fn from(trb: anytype) *Trb {
        const typeInfo = @typeInfo(@TypeOf(trb));
        if (typeInfo != .pointer) {
            @compileError(std.fmt.cmptimePrint(
                "Trb.from: expected pointer, got {s}",
                .{@typeName(@TypeOf(trb))},
            ));
        }
        const child = typeInfo.pointer.child;
        if (@sizeOf(child) != @sizeOf(Trb)) {
            @compileError(std.fmt.comptimePrint(
                "Trb.from: invalid size: {d}",
                .{@sizeOf(child)},
            ));
        }

        if (@FieldType(child, "type") != TrbType) {
            @compileError(std.fmt.comptimePrint(
                "Trb.from: expected type field to be TrbType, got {s}",
                .{@typeName(@FieldType(child, "type"))},
            ));
        }

        return @ptrCast(trb);
    }
};

/// Normal TRB.
pub const NormalTrb = packed struct(u128) {
    /// Address of the TRB data area or 8 bytes of immediate data.
    data_buffer: [*]u8,

    /// Transfer length.
    length: u17,
    /// Indicator of the number of packets remaining in the TD.
    td_size: u5,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Interrupt-on Short Packet.
    isp: bool,
    /// No Snoop.
    ns: bool,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved1: u2 = 0,
    /// Block Event Interrupt.
    bei: bool,
    /// TRB type.
    type: TrbType = .normal,
    /// Reserved.
    _reserved2: u6 = 0,
};

/// Setup Stage TRB.
///
/// Used to initiate a USB Setup packet on a control endpoint.
pub const SetupTrb = packed struct(u128) {
    /// TODO doc
    request_type: u8,
    /// TODO doc
    request: u8,
    /// TODO doc
    value: u16,

    /// TODO doc
    index: u16,
    /// TODO doc
    length: u16,

    /// TRB Transfer Length.
    /// Always 8.
    trransfer_length: u17 = 8,
    /// Reserved.
    _reserved1: u5 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Reserved
    _reserved2: u4 = 0,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved3: u3 = 0,
    /// TRB type.
    type: TrbType = .setup,
    /// Reserved.
    _reserved4: u14 = 0,
};

/// Data Stage TRB.
///
/// Used to generate the Data stage transaction.
pub const DataTrb = packed struct(u128) {
    /// Data Buffer Pointer.
    data_buffer: [*]u8,

    /// Transfer length.
    length: u17,
    /// Indicator of the number of packets remaining in the TD.
    td_size: u5,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Interrupt-on Short Packet.
    isp: bool,
    /// No Snoop.
    ns: bool,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved1: u3 = 0,
    /// TRB type.
    type: TrbType = .data,
    /// Direction.
    direction: Direction,
    /// Reserved.
    _reserved2: u15 = 0,
};

/// Status Stage TRB.
///
/// Used to generate the Status stage transaction.
pub const StatusTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u64 = 0,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// TRB type.
    type: TrbType = .status,
    /// Direction.
    direction: Direction,
    /// Reserved.
    _reserved4: u14 = 0,
};

/// Link TRB.
pub const LinkTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u4 = 0,
    /// Ring Segment Pointer.
    /// 64-bit address of the next Ring Segment.
    ring_segment: u60,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10 = 0,

    /// Cycle bit.
    cycle: u1 = undefined,
    /// Toggle Cycle.
    /// If true, the xHC shall toggle its interpretation of the Cycle bit.
    tc: bool = true,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool = false,
    /// Reserved.
    _reserved4: u4 = 0,
    /// TRB type.
    type: TrbType = .link,
    /// Reserved.
    _reserved5: u16 = 0,

    pub fn new(ring_segment: []volatile Trb) LinkTrb {
        return .{
            .ring_segment = @intCast(@intFromPtr(ring_segment.ptr) >> 4),
            .chain = false,
            .ioc = false,
        };
    }
};

/// No Op TRB.
///
/// Used to verify the operation of the basic Transfer Ring mechanisms offered by the xHC.
pub const NoopTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u64 = 0,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Reserved.
    _reserved4: u4 = 0,
    /// TRB type.
    type: TrbType = .noop,
    /// Reserved.
    _reserved5: u17 = 0,
};

/// Port Status Change Event TRB.
///
/// Generated by the xHC when PSCEG (Port Status Change Event Generation) is set to 1.
pub const PortStatusChange = packed struct(u128) {
    /// Reserved.
    _reserved1: u24 = 0,
    /// Port ID.
    port: u8,

    /// Reserved.
    _reserved2: u56 = 0,
    /// Completion Code.
    code: u8,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved3: u9 = 0,
    /// TRB type.
    type: TrbType = .port_status_change,
    /// Reserved.
    _reserved4: u16 = 0,
};

/// Type of TRB.
pub const TrbType = enum(u6) {
    /// Normal TRB.
    normal = 1,
    /// Setup Stage TRB.
    setup = 2,
    /// Data Stage TRB.
    data = 3,
    /// Status Stage TRB.
    status = 4,
    /// Link TRB.
    link = 6,
    /// No Op TRB.
    noop = 8,
    /// Port Status Change Event TRB.
    port_status_change = 34,
};

/// Transfer direction.
pub const Direction = enum(u1) {
    in = 0,
    out = 1,
};

// =============================================================
// Imports
// =============================================================

const std = @import("std");

const norn = @import("norn");
