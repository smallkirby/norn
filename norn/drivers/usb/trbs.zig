/// Type-erased TRB.
pub const Trb = packed struct(u128) {
    /// Parameter. Ring-specific.
    parameter: u64,
    /// Status. Ring-specific.
    status: u32,
    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    ent: u1,
    /// Ring-specific field.
    _ring_specific: u8,
    /// Type of TRB.
    type: TrbType,
    /// Control. Ring-specific.
    control: u16,

    /// Obtain the abstract type of the TRB.
    pub fn from(trb: anytype) *Trb {
        const typeInfo = @typeInfo(@TypeOf(trb));
        if (typeInfo != .pointer) {
            @compileError(std.fmt.cmptimePrint(
                "Trb.from: expected pointer, got {s}",
                .{@typeName(@TypeOf(trb))},
            ));
        }
        const child = typeInfo.pointer.child;
        if (@sizeOf(child) != @sizeOf(Trb)) {
            @compileError(std.fmt.comptimePrint(
                "Trb.from: invalid size: {d}",
                .{@sizeOf(child)},
            ));
        }

        if (@FieldType(child, "type") != TrbType) {
            @compileError(std.fmt.comptimePrint(
                "Trb.from: expected type field to be TrbType, got {s}",
                .{@typeName(@FieldType(child, "type"))},
            ));
        }

        return @ptrCast(trb);
    }
};

/// Normal TRB.
pub const NormalTrb = packed struct(u128) {
    /// Address of the TRB data area or 8 bytes of immediate data.
    data_buffer: Phys,

    /// Transfer length.
    length: u17,
    /// Indicator of the number of packets remaining in the TD.
    td_size: u5,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Interrupt-on Short Packet.
    isp: bool,
    /// No Snoop.
    ns: bool,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved1: u2 = 0,
    /// Block Event Interrupt.
    bei: bool,
    /// TRB type.
    type: TrbType = .normal,
    /// Reserved.
    _reserved2: u16 = 0,
};

/// Setup Stage TRB.
///
/// Used to initiate a USB Setup packet on a control endpoint.
pub const SetupTrb = packed struct(u128) {
    /// bmRequestType.
    request_type: u8,
    /// bRequest.
    request: u8,
    /// wValue.
    value: u16,

    /// wIndex. Varying by request type.
    index: u16,
    /// wLength. Length of the data transferred.
    length: u16,

    /// TRB Transfer Length.
    /// Always 8.
    transfer_length: u17 = 8,
    /// Reserved.
    _reserved1: u5 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Reserved
    _reserved2: u4 = 0,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved3: u3 = 0,
    /// TRB type.
    type: TrbType = .setup,
    /// Transfer type.
    trt: TransferType,
    /// Reserved.
    _reserved4: u14 = 0,

    const TransferType = enum(u2) {
        no_data = 0,
        _reserved = 1,
        out = 2,
        in = 3,
    };
};

/// Data Stage TRB.
///
/// Used to generate the Data stage transaction.
pub const DataTrb = packed struct(u128) {
    /// Data Buffer Pointer.
    data_buffer: Phys,

    /// TRB transfer length.
    transfer_length: u17,
    /// Indicator of the number of packets remaining in the TD.
    td_size: u5,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Interrupt-on Short Packet.
    isp: bool,
    /// No Snoop.
    ns: bool,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved1: u3 = 0,
    /// TRB type.
    type: TrbType = .data,
    /// Direction.
    direction: Direction,
    /// Reserved.
    _reserved2: u15 = 0,
};

/// Status Stage TRB.
///
/// Used to generate the Status stage transaction.
pub const StatusTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u64 = 0,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Reserved.
    _reserved4: u4 = 0,
    /// TRB type.
    type: TrbType = .status,
    /// Direction.
    direction: Direction,
    /// Reserved.
    _reserved5: u15 = 0,
};

/// Link TRB.
pub const LinkTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u4 = 0,
    /// Ring Segment Pointer.
    /// 64-bit address of the next Ring Segment.
    ring_segment: u60,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10 = 0,

    /// Cycle bit.
    cycle: u1 = undefined,
    /// Toggle Cycle.
    /// If true, the xHC shall toggle its interpretation of the Cycle bit.
    tc: bool = true,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool = false,
    /// Reserved.
    _reserved4: u4 = 0,
    /// TRB type.
    type: TrbType = .link,
    /// Reserved.
    _reserved5: u16 = 0,

    pub fn new(ring_segment: []volatile Trb) LinkTrb {
        return .{
            .ring_segment = @intCast(@intFromPtr(ring_segment.ptr) >> 4),
            .chain = false,
            .ioc = false,
        };
    }
};

/// No Op TRB.
///
/// Used to verify the operation of the basic Transfer Ring mechanisms offered by the xHC.
pub const NoopTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u64 = 0,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Reserved.
    _reserved4: u4 = 0,
    /// TRB type.
    type: TrbType = .noop,
    /// Reserved.
    _reserved5: u17 = 0,
};

/// Enable Slot Command TRB.
///
/// Causes the xHC to select an available Device Slot and return the Slot ID.
pub const EnableSlotTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u32 = 0,
    /// Reserved.
    _reserved2: u32 = 0,
    /// Reserved.
    _reserved3: u32 = 0,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved4: u9 = 0,
    /// TRB type.
    type: TrbType = .enable_slot,
    /// USB Slot Type.
    slot_type: u5 = 0,
    /// Reserved.
    _reserved5: u11 = 0,
};

/// Address Device Command TRB.
///
/// Causes the xHC to select an address for the USB device.
pub const AddressDeviceTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u4 = 0,
    /// Input Context Pointer.
    /// High 60-bit address of the Input Context data structure.
    context: u60,

    /// Reserved.
    _reserved2: u32 = 0,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved3: u8 = 0,
    /// Block Set Address Request.
    /// If set to false, the command generates a USB SET_ADDRESS request.
    bsr: bool = false,
    /// TRB type.
    type: TrbType = .address_device,
    /// Reserved.
    _reserved4: u8 = 0,
    /// Target Slot ID.
    slot: u8,

    pub fn from(slot: u8, dc: *const anyopaque) AddressDeviceTrb {
        norn.rtt.expectEqual(0, mem.virt2phys(dc) & 0xF);

        return AddressDeviceTrb{
            .context = @intCast(mem.virt2phys(dc) >> 4),
            .cycle = undefined,
            .slot = slot,
        };
    }
};

/// Configure Endpoint Command TRB.
///
/// Evaluates the bandwidth and resource requirements of the endpoints selected by the command.
pub const ConfigureEndpointTrb = packed struct(u128) {
    /// Address of the Input Context data structure.
    input_context: Phys,

    /// Reserved.
    _reserved2: u32 = 0,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved3: u8 = 0,
    /// Deconfigure.
    dc: bool = false,
    /// TRB type.
    type: TrbType = .configure_endpoint,
    /// Reserved.
    _reserved4: u8 = 0,
    /// Target Slot ID.
    slot: u8,

    pub fn from(slot: u8, context: *const anyopaque) ConfigureEndpointTrb {
        norn.rtt.expectEqual(0, mem.virt2phys(context) & 0xF);

        return ConfigureEndpointTrb{
            .input_context = mem.virt2phys(context),
            .cycle = undefined,
            .slot = slot,
        };
    }
};

/// Transfer Event TRB.
///
/// Provides the completion status associated with a Transfer TRB.
pub const TransferEventTrb = packed struct(u128) {
    /// Address of the TRB that generated this event.
    trb: Phys,

    /// TRB Transfer Length.
    ///
    /// Residual number of bytes not transferred.
    length: u24,
    /// Completion Code.
    code: ErrorCode,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved1: u1 = 0,
    /// Event Data.
    ///
    /// If 1, the event was generated by an Event Data TRB and the pointer contains a 64-bit value provided by the Event Data TRB.
    /// If 0, the pointer contains a pointer to the TRB that generated this event.
    ed: u1 = 0,
    /// Reserved.
    _reserved2: u7 = 0,
    /// TRB type.
    type: TrbType = .transfer_event,
    /// Endpoint ID.
    endpoint: u5,
    /// Reserved.
    _reserved3: u3 = 0,
    /// The Slot ID that generated this event.
    slot_id: u8,
};

/// Command Completion Event TRB.
pub const CommandCompletionTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u4 = 0,
    /// High 60 bits of the Command TRB that generated this event.
    command_trb: u60 = 0,

    /// Command Completion Parameter.
    param: u24,
    /// Completion Code. Depends on the command.
    code: ErrorCode,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved2: u9 = 0,
    /// TRB type.
    type: TrbType = .command_completion,
    /// The ID of the Virtual Function that generated this event.
    vfid: u8,
    /// The Slot ID that generated this event.
    slot_id: u8,

    /// Get the pointer to the Command TRB that generated this event.
    pub fn commandTrb(self: *const volatile CommandCompletionTrb) *const volatile Trb {
        return @ptrFromInt(mem.phys2virt(@as(u64, self.command_trb) << 4));
    }
};

/// Port Status Change Event TRB.
///
/// Generated by the xHC when PSCEG (Port Status Change Event Generation) is set to 1.
pub const PortStatusChange = packed struct(u128) {
    /// Reserved.
    _reserved1: u24 = 0,
    /// Port ID.
    port: u8,

    /// Reserved.
    _reserved2: u56 = 0,
    /// Completion Code.
    code: ErrorCode,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved3: u9 = 0,
    /// TRB type.
    type: TrbType = .port_status_change,
    /// Reserved.
    _reserved4: u16 = 0,
};

/// Type of TRB.
pub const TrbType = enum(u6) {
    /// Normal TRB.
    normal = 1,
    /// Setup Stage TRB.
    setup = 2,
    /// Data Stage TRB.
    data = 3,
    /// Status Stage TRB.
    status = 4,
    /// Link TRB.
    link = 6,
    /// No Op TRB.
    noop = 8,
    /// Enable Slot Command TRB.
    enable_slot = 9,
    /// Address Device Command TRB.
    address_device = 11,
    /// Configure Endpoint Command TRB.
    configure_endpoint = 12,
    /// Transfer Event.
    transfer_event = 32,
    /// Command Completion Event TRB.
    command_completion = 33,
    /// Port Status Change Event TRB.
    port_status_change = 34,

    _,
};

/// Transfer direction.
pub const Direction = enum(u1) {
    out = 0,
    in = 1,
};

/// TRB completion codes.
pub const ErrorCode = enum(u8) {
    invalid = 0,
    success = 1,
    data_buffer_error = 2,
    babble_detected = 3,
    transaction_error = 4,
    trb_error = 5,
    stall_error = 6,
    resource_error = 7,
    bandwidth_error = 8,
    no_slots_available = 9,
    invalid_stream = 10,
    slot_not_enabled = 11,
    endpoint_not_enabled = 12,
    short_packet = 13,
    ring_underrun = 14,
    ring_overrun = 15,
    vf_event_ring_full = 16,
    parameter_error = 17,
    bandwidth_overrun = 18,
    context_state_error = 19,
    no_ping_response = 20,
    event_ring_full = 21,
    incompatible_device = 22,
    missed_service = 23,
    command_ring_stop = 24,
    command_aborted = 25,
    stopped = 26,
    stopped_length_invalid = 27,
    stopped_short_packet = 28,
    max_exit_latency = 29,
    _reserved1 = 30,
    isoch_buffer_overrun = 31,
    event_lost = 32,
    undefined_error = 33,
    invalid_stream_id = 34,
    secondary_bandwidth_error = 35,
    split_transaction_error = 36,

    _,
};

// =============================================================
// Imports
// =============================================================

const std = @import("std");

const norn = @import("norn");
const mem = norn.mem;
const Phys = mem.Phys;
