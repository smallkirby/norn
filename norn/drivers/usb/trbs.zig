/// TODO: doc
pub const Trb = packed struct(u128) {
    /// Type-specific data.
    _unknown1: u64,

    /// Type-specific data.
    _unknown2: u32,

    /// Cycle bit.
    cycle: u1,
    /// Type-specific data.
    _unknown3: u9,
    /// TRB type.
    ///
    /// TODO: the offset of `type` field is different in each TRB type.
    type: TrbType,
    /// Type-specific data.
    _unknown4: u16,

    /// Obtain the abstract type of the TRB.
    pub fn from(trb: anytype) *Trb {
        const typeInfo = @typeInfo(@TypeOf(trb));
        if (typeInfo != .pointer) {
            @compileError(std.fmt.cmptimePrint(
                "Trb.from: expected pointer, got {s}",
                .{@typeName(@TypeOf(trb))},
            ));
        }
        const child = typeInfo.pointer.child;
        if (@sizeOf(child) != @sizeOf(Trb)) {
            @compileError(std.fmt.comptimePrint(
                "Trb.from: invalid size: {d}",
                .{@sizeOf(child)},
            ));
        }

        if (@FieldType(child, "type") != TrbType) {
            @compileError(std.fmt.comptimePrint(
                "Trb.from: expected type field to be TrbType, got {s}",
                .{@typeName(@FieldType(child, "type"))},
            ));
        }

        return @ptrCast(trb);
    }
};

/// Normal TRB.
pub const NormalTrb = packed struct(u128) {
    /// Address of the TRB data area or 8 bytes of immediate data.
    data_buffer: [*]u8,

    /// Transfer length.
    length: u17,
    /// Indicator of the number of packets remaining in the TD.
    td_size: u5,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Interrupt-on Short Packet.
    isp: bool,
    /// No Snoop.
    ns: bool,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved1: u2 = 0,
    /// Block Event Interrupt.
    bei: bool,
    /// TRB type.
    type: TrbType = .normal,
    /// Reserved.
    _reserved2: u6 = 0,
};

/// Setup Stage TRB.
///
/// Used to initiate a USB Setup packet on a control endpoint.
pub const SetupTrb = packed struct(u128) {
    /// TODO doc
    request_type: u8,
    /// TODO doc
    request: u8,
    /// TODO doc
    value: u16,

    /// TODO doc
    index: u16,
    /// TODO doc
    length: u16,

    /// TRB Transfer Length.
    /// Always 8.
    trransfer_length: u17 = 8,
    /// Reserved.
    _reserved1: u5 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Reserved
    _reserved2: u4 = 0,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved3: u3 = 0,
    /// TRB type.
    type: TrbType = .setup,
    /// Reserved.
    _reserved4: u14 = 0,
};

/// Data Stage TRB.
///
/// Used to generate the Data stage transaction.
pub const DataTrb = packed struct(u128) {
    /// Data Buffer Pointer.
    data_buffer: [*]u8,

    /// Transfer length.
    length: u17,
    /// Indicator of the number of packets remaining in the TD.
    td_size: u5,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Interrupt-on Short Packet.
    isp: bool,
    /// No Snoop.
    ns: bool,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Immediate Data.
    /// If true, the data buffer field contains data, not a pointer.
    /// The length (0..8) field contains the size of the immediate data.
    idt: bool,
    /// Reserved.
    _reserved1: u3 = 0,
    /// TRB type.
    type: TrbType = .data,
    /// Direction.
    direction: Direction,
    /// Reserved.
    _reserved2: u15 = 0,
};

/// Status Stage TRB.
///
/// Used to generate the Status stage transaction.
pub const StatusTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u64 = 0,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// TRB type.
    type: TrbType = .status,
    /// Direction.
    direction: Direction,
    /// Reserved.
    _reserved4: u14 = 0,
};

/// Link TRB.
pub const LinkTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u4 = 0,
    /// Ring Segment Pointer.
    /// 64-bit address of the next Ring Segment.
    ring_segment: u60,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10 = 0,

    /// Cycle bit.
    cycle: u1 = undefined,
    /// Toggle Cycle.
    /// If true, the xHC shall toggle its interpretation of the Cycle bit.
    tc: bool = true,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool = false,
    /// Reserved.
    _reserved4: u4 = 0,
    /// TRB type.
    type: TrbType = .link,
    /// Reserved.
    _reserved5: u16 = 0,

    pub fn new(ring_segment: []volatile Trb) LinkTrb {
        return .{
            .ring_segment = @intCast(@intFromPtr(ring_segment.ptr) >> 4),
            .chain = false,
            .ioc = false,
        };
    }
};

/// No Op TRB.
///
/// Used to verify the operation of the basic Transfer Ring mechanisms offered by the xHC.
pub const NoopTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u64 = 0,

    /// Reserved.
    _reserved2: u22 = 0,
    /// Index of the Interrupter that will receive events generated by this TRB.
    intr_target: u10,

    /// Cycle bit.
    cycle: u1,
    /// Evaluate Next TRB.
    /// If true, xHC shall fetch and evaluate the next TRB before saving the endpoint state.
    ent: bool,
    /// Reserved.
    _reserved3: u2 = 0,
    /// Chain bit.
    chain: bool,
    /// Interrupt On Completion.
    ioc: bool,
    /// Reserved.
    _reserved4: u4 = 0,
    /// TRB type.
    type: TrbType = .noop,
    /// Reserved.
    _reserved5: u17 = 0,
};

/// Enable Slot Command TRB.
///
/// Causes the xHC to select an available Device Slot and return the Slot ID.
pub const EnableSlotTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u32 = 0,
    /// Reserved.
    _reserved2: u32 = 0,
    /// Reserved.
    _reserved3: u32 = 0,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved4: u9 = 0,
    /// TRB type.
    type: TrbType = .enable_slot,
    /// USB Slot Type.
    slot_type: u5 = 0,
    /// Reserved.
    _reserved5: u11 = 0,
};

/// Address Device Command TRB.
///
/// Causes the xHC to select an address for the USB device.
pub const AddressDeviceTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u4 = 0,
    /// Input Context Pointer.
    /// High 60-bit address of the Input Context data structure.
    context: u60,

    /// Reserved.
    _reserved2: u32 = 0,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved3: u8 = 0,
    /// Block Set Address Request.
    /// If set to false, the command generates a USB SET_ADDRESS request.
    bsr: bool = false,
    /// TRB type.
    type: TrbType = .address_device,
    /// Reserved.
    _reserved4: u8 = 0,
    /// Target Slot ID.
    slot: u8,

    pub fn from(slot: u8, dc: *const anyopaque) AddressDeviceTrb {
        norn.rtt.expectEqual(0, mem.virt2phys(dc) & 0xF);

        return AddressDeviceTrb{
            .context = @intCast(mem.virt2phys(dc) >> 4),
            .cycle = undefined,
            .slot = slot,
        };
    }
};

/// Command Completion Event TRB.
pub const CommandCompletionTrb = packed struct(u128) {
    /// Reserved.
    _reserved1: u4 = 0,
    /// High 60 bits of the Command TRB that generated this event.
    command_trb: u60 = 0,

    /// Command Completion Parameter.
    param: u24,
    /// Completion Code. Depends on the command.
    code: u8,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved2: u9 = 0,
    /// TRB type.
    type: TrbType = .command_completion,
    /// The ID of the Virtual Function that generated this event.
    vfid: u8,
    /// The Slot ID that generated this event.
    slot_id: u8,

    /// Get the pointer to the Command TRB that generated this event.
    pub fn commandTrb(self: *const volatile CommandCompletionTrb) *const volatile Trb {
        return @ptrFromInt(mem.phys2virt(@as(u64, self.command_trb) << 4));
    }
};

/// Port Status Change Event TRB.
///
/// Generated by the xHC when PSCEG (Port Status Change Event Generation) is set to 1.
pub const PortStatusChange = packed struct(u128) {
    /// Reserved.
    _reserved1: u24 = 0,
    /// Port ID.
    port: u8,

    /// Reserved.
    _reserved2: u56 = 0,
    /// Completion Code.
    code: u8,

    /// Cycle bit.
    cycle: u1,
    /// Reserved.
    _reserved3: u9 = 0,
    /// TRB type.
    type: TrbType = .port_status_change,
    /// Reserved.
    _reserved4: u16 = 0,
};

/// Type of TRB.
pub const TrbType = enum(u6) {
    /// Normal TRB.
    normal = 1,
    /// Setup Stage TRB.
    setup = 2,
    /// Data Stage TRB.
    data = 3,
    /// Status Stage TRB.
    status = 4,
    /// Link TRB.
    link = 6,
    /// No Op TRB.
    noop = 8,
    /// Enable Slot Command TRB.
    enable_slot = 9,
    /// Address Device Command TRB.
    address_device = 11,
    /// Command Completion Event TRB.
    command_completion = 33,
    /// Port Status Change Event TRB.
    port_status_change = 34,

    _,
};

/// Transfer direction.
pub const Direction = enum(u1) {
    in = 0,
    out = 1,
};

// =============================================================
// Imports
// =============================================================

const std = @import("std");

const norn = @import("norn");
const mem = norn.mem;
